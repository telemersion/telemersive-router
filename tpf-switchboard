#!/usr/bin/env python3
# -*- coding: utf-8 -*-

"""
tpf-switchboard creates and destroys udp proxies dynamically on request.
"""

import copy
import sys
import time
import proxies
from flask import Flask, json, Response, request

# format of myproxies
# myproxies = {
#      4484: {
#          'obj': <proxy_obj>,
#          'type': 'simple',
#          'description': 'Some description about the proxy'
#      }
# }
# valid types: 'simple', 'multi', 'mirror'
myproxies = {}

port_range = range(10000, 32768)
baseroute = '/proxies/'
valid_types = ['mirror', 'one2oneBi', 'one2manyMo']
listen_port = 3591
listen_address = '0.0.0.0'

api = Flask(__name__)

class r(Response):
    default_mimetype = 'application/json'

def representation_format(proxy):
    r_proxy = {}
    for key in proxy.keys():
        if key != 'obj':
            r_proxy[key] = proxy[key]
    return r_proxy

@api.route(baseroute, methods=['POST'])
def start_proxy():
    proxydef = request.get_json()
    # Do some input sanitizing
    # port
    try:
        assert proxydef['port'] in port_range
        assert isinstance(proxydef['port'], int)
    except AssertionError:
        response = {'status': 'Error', 'msg': 'Allowed port range is %s - %s' % (min(port_range), max(port_range))}
        return r(json.dumps(response), 422)
    except KeyError:
        response = {'status': 'Error', 'msg': 'No description specified'}
        return r(json.dumps(response), 422)
    # type
    try:
        assert proxydef['type'] in valid_types
        assert isinstance(proxydef['type'], str)
    except AssertionError:
        response = {'status': 'Error', 'msg': 'Invalid type specified: %s' % proxydef['type']}
        return r(json.dumps(response), 422)
    except KeyError:
        response = {'status': 'Error', 'msg': 'No description specified'}
        return r(json.dumps(response), 422)
    # description
    try:
        assert isinstance(proxydef['description'], str)
    except AssertionError:
        response = {'status': 'Error', 'msg': 'Invalid description specified'}
        return r(json.dumps(response), 422)
    except KeyError:
        response = {'status': 'Error', 'msg': 'No description specified'}
        return r(json.dumps(response), 422)
    # Done input sanitizing
    try:
        myproxies[proxydef['port']]
    except KeyError:
        try:
            if proxydef['type'] == 'one2oneBi':
                obj = proxies.One2OneBiProxy(listen_port=proxydef['port'])
            elif proxydef['type'] == 'one2manyMo':
                obj = proxies.One2ManyMoProxy(listen_port=proxydef['port'], send_port=proxydef['port']+5)
            elif proxydef['type'] == 'mirror':
                obj = proxies.MirrorProxy(listen_port=proxydef['port'])
            else:
                response = {'status': 'Error', 'msg': 'An unknown error occurred'}
                return r(json.dumps(response), 422)
        except OSError as err:
            response = {'status': 'Error', 'msg': str(err)}
            return r(json.dumps(response), 422)
        else:
            obj.start()
            myproxies[proxydef['port']] = {
                'obj': obj,
                'port': proxydef['port'],
                'type': proxydef['type'],
                'desc': proxydef['description']
            }
            response = {'status': 'OK', 'msg': 'Proxy successfully started'}
            return r(json.dumps(response))
    else:
        response = {'status': 'Error', 'msg': 'Proxy already running on port %s' % proxydef['port']}
        return r(json.dumps(response), 422)

@api.route(baseroute + '<int:port>', methods=['DELETE'])
def stop_proxy(port):
    try:
        myproxies[port]['obj'].stop()
        del myproxies[port]
        response = {'status': 'OK', 'msg': 'Proxy successfully stopped'}
        return r(json.dumps(response))
    except KeyError:
        response = {'status': 'OK', 'msg': 'Proxy is not running'}
        return r(json.dumps(response))

@api.route(baseroute, methods=['GET'])
def list_proxies():
    proxies = {}
    for key in myproxies.keys():
        proxies[key] = representation_format(myproxies[key])
    return r(json.dumps(proxies))

@api.route(baseroute + '<int:port>', methods=['GET'])
def get_proxy(port):
    try:
        proxy = representation_format(myproxies[port])
        return r(json.dumps(proxy))
    except KeyError:
        return r(json.dumps({'status': 'Error', 'msg': 'No proxy running on this port'}), 404)

if __name__ == '__main__':
    api.run(host=listen_address, port=listen_port)
