#!/usr/bin/env python3

import socket
import sys
import threading
import time

UDP_IP = "0.0.0.0"
# timeout in seconds
timeout = 3

try:
    UDP_PORT_SENDER = int(sys.argv[1])
    UDP_PORT_MANY = UDP_PORT_SENDER + 5
except ValueError:
    sys.stderr.write('Specified port is not a number\n')
    sys.exit(1)

if not isinstance(UDP_PORT_SENDER, int) or not  1024 <= UDP_PORT_SENDER <= 40000:
    sys.stderr.write('Specified port "%s" is invalid.\n' % UDP_PORT_SENDER)
    sys.stderr.write('Valid port range: 1024 - 40000\n')
    sys.exit(1)

# Lass uns die socket erzeugen
try:
    sock_sender = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
    sock_sender.bind((UDP_IP, UDP_PORT_SENDER))
    sock_sender.settimeout(0.1)
    sock_many = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
    sock_many.bind((UDP_IP, UDP_PORT_MANY))
    sock_many.settimeout(0.1)
except socket.error as msg:
    sys.stderr.write("[ERROR] %s\n" % msg[1])
    sys.exit(1)

addr = None
stop = False
# dictionary mit allen addr tuple und update mit current timestamp
clientMany = {}
clientSender = None
clientSenderLastTime = 0
clientSenderOld = None

# Define a function for the sender loop
def sender_loop():
    global clientSender
    global clientSenderLastTime
    global clientSenderOld
    while not stop:
        try:
            data, addr = sock_sender.recvfrom(65536)
        except socket.timeout:
            continue
        # cleanup dictionary mit aktuellem timestamp
        for key, value in list(clientMany.items()):
            if (value + timeout) < time.time():
                del clientMany[key]
        # send data to all surviving addresses
        for key in clientMany.keys():
            sock_many.sendto(data, key)
	# check if sender address has changed
        if clientSender != addr:
            clientSender = addr
            # update file with current connections
            save_file()
            clientSenderLastTime = time.time()
            clientSenderOld = addr

# Define a function for the many (receiver) loop
def many_loop():
    global clientMany
    while not stop:
        try:
            data, addr = sock_many.recvfrom(65536)
        except socket.timeout:
            continue
        # update dictionary mit aktuellem timestamp
        clientMany [addr] = time.time()
        # update file with current connections
        save_file()

def save_file():
    global clientSender
    global clientMany
    global clientSenderLastTime
    global clientSenderOld
    text_file = open("/var/www/html/ports/" + str(UDP_PORT_SENDER) + ".txt", "w")
    if clientSenderLastTime > time.time() - 1:
        text_file.write("WARNING: Two senders detected: " + str(clientSender) +  ", " + str(clientSenderOld) + "\n")
    else:
        text_file.write(str(clientSender) + " > " + str(list(clientMany.keys())) + "\n")
    text_file.close()

def main():
    global clientSender, stop
    source_thread = threading.Thread(target=sender_loop)
    source_thread.start()
    destination_thread = threading.Thread(target=many_loop)
    destination_thread.start()

    save_file()
    
    try:
        while True:
           # pass wuerde unnoetigerweise die CPU am Anschlag laufen lassen
           time.sleep(1)
           if clientSender != None and clientSenderLastTime < time.time() - 10:
               clientSender = None
               save_file()
           if clientSender == None and len(clientMany) > 0:
               for key, value in list(clientMany.items()):
                   if((value + timeout) < time.time()):
                       del clientMany[key]
                       save_file()
    except KeyboardInterrupt:
        stop = True
        sys.exit(0)

if __name__ == '__main__':
    main()

